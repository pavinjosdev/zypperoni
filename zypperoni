#!/usr/bin/env python3
#
# SPDX-License-Identifier: GPL-3.0-only
#
# Copyright (C) 2024  Pavin Joseph <https://github.com/pavinjosdev>
#
# zypperoni is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# zypperoni is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with zypperoni; if not, see <http://www.gnu.org/licenses/>.

import os
import sys
import time
import logging
import asyncio
import tempfile
import subprocess
from uuid import uuid4
from shlex import quote
import xml.etree.ElementTree as ET

# Constants
ZYPPPERONI_VERSION = "0.3.5"
ZYPPER_PID_FILE = "/run/zypp.pid"
VALID_CMD = ["ref", "force-ref", "in", "in-download", "dup", "dup-download", "inr", "inr-download"]
VALID_OPT = ["--debug", "--help", "--version", "--no-confirm", "--max-jobs"]

# Create secure temp dir
ZYPPERONI_TMP_DIR = tempfile.mkdtemp(dir="/tmp", prefix="zypperoni_")

# Command help/usage info
help_text = """
Usage: zypperoni [options] command
       zypperoni [options] in pkg1 [pkg2 ...]
       zypperoni [options] in-download pkg1 [pkg2 ...]

zypperoni provides parallel operations
for zypper's oft-used time consuming commands.

Commands:
  ref           - Refresh all enabled repos
  force-ref     - Force refresh all enabled repos
  in            - Install packages
  in-download   - Download packages for later installation
  dup           - Perform distribution upgrade
  dup-download  - Download packages required for distribution upgrade
  inr           - Install new packages recommended by already installed ones
  inr-download  - Download new packages recommended by already installed ones

Options:
  --debug       - Enable debug output
  --help        - Print this help and exit
  --version     - Print version number and exit
  --no-confirm  - Automatic yes to prompts, run non-interactively
  --max-jobs    - Maximum number of parallel operations [default: 10 / max: 20]
"""

# Shell commands to prepare temp mounts for zypper refresh
refresh_mount_commands = f"""
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/run;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/var/cache/zypp;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/var/lib/ca-certificates;
if readlink /etc/resolv.conf; then
    RESOLV_PATH=$(readlink /etc/resolv.conf);
    TEMP_DIR={ZYPPERONI_TMP_DIR}/{{uuid}}"$(dirname "$RESOLV_PATH")";
    mkdir -p "$TEMP_DIR";
    cat "$RESOLV_PATH" > "$TEMP_DIR"/"$(basename "$RESOLV_PATH")";
fi;
mount -o bind,ro / {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs;
mount -t devtmpfs none {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/dev;
mount -t tmpfs none {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/tmp;
mount -o bind {ZYPPERONI_TMP_DIR}/{{uuid}}/run {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/run;
mount -o bind {ZYPPERONI_TMP_DIR}/{{uuid}}/var {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var;
mount -o bind /var/cache/zypp {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/cache/zypp;
mount -o bind,ro /var/lib/ca-certificates {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/lib/ca-certificates;
"""

# Shell commands to perform zypper refresh / force-refresh
refresh_shell_commands = f"""
chroot {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs env -i zypper --non-interactive {{refresh_type}} {{repo_alias}};
"""

# Shell commands to prepare temp mounts for zypper download
download_mount_commands = f"""
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/run;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/var/cache/zypp;
mkdir -p {ZYPPERONI_TMP_DIR}/{{uuid}}/var/lib/ca-certificates;
if readlink /etc/resolv.conf; then
    RESOLV_PATH=$(readlink /etc/resolv.conf);
    TEMP_DIR={ZYPPERONI_TMP_DIR}/{{uuid}}"$(dirname "$RESOLV_PATH")";
    mkdir -p "$TEMP_DIR";
    cat "$RESOLV_PATH" > "$TEMP_DIR"/"$(basename "$RESOLV_PATH")";
fi;
mount -o bind,ro / {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs;
mount -o bind {ZYPPERONI_TMP_DIR}/{{uuid}}/run {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/run;
mount -o bind {ZYPPERONI_TMP_DIR}/{{uuid}}/var {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var;
mount -o bind /var/cache/zypp {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/cache/zypp;
mount -o bind,ro /var/lib/ca-certificates {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/lib/ca-certificates;
"""

# Shell commands to perform zypper download
download_shell_commands = f"""
chroot {ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs env -i zypper --non-interactive download {{pkg_name}};
"""

# Dirs to unmount (one per line)
umount_dirs = f"""
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/lib/ca-certificates
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var/cache/zypp
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/var
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/run
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/tmp
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs/dev
{ZYPPERONI_TMP_DIR}/{{uuid}}/rootfs
"""

# ANSI color codes
COLOR_RESET = "\033[0m"
COLOR_INFO = "\033[1;34m"  # Bright Blue
COLOR_ERROR = "\033[1;31m"  # Bright Red
COLOR_DEBUG = "\033[36m"  # Cyan
COLOR_WARNING = "\033[1;33m"  # Bright Yellow
COLOR_QUESTION = "\033[1;32m"  # Bright Green

################################

# Function to query user for yes or no
def query_yes_no(question, default=None):
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}
    if default is None:
        prompt = f" {COLOR_QUESTION}[y/n]: {COLOR_RESET}"
    elif default == "yes":
        prompt = f" {COLOR_QUESTION}[Y/n]: {COLOR_RESET}"
    elif default == "no":
        prompt = f" {COLOR_QUESTION}[y/N]: {COLOR_RESET}"
    else:
        raise ValueError(f"Invalid default answer: {default!r}")
    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == "":
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write(f"{COLOR_WARNING}Please respond with 'yes' or 'no' (or 'y' or 'n').{COLOR_RESET}\n")

# Function to take exclusive control of future zypper invocations
def get_zypp_lock():
    our_pid = os.getpid()
    os.system(f"echo {our_pid} > {ZYPPER_PID_FILE}")
    return our_pid

# Function to release lock on zypper
def release_zypp_lock():
    if os.getuid() == 0:
        os.system(f"echo -n > {ZYPPER_PID_FILE}")
        return True
    else:
        return False

# Function to unmount temp dirs provided list of UUIDs
def unmount(UUID):
    umount_counter = 0
    while umount_counter < len(UUID):
        umount_counter = 0
        for uuid in UUID:
            UMNT_OK = True
            if os.path.isdir(f"{ZYPPERONI_TMP_DIR}/{uuid}/rootfs"):
                dirs = umount_dirs.format(uuid=uuid)
                dirs = dirs.strip().split("\n")
                for dir in dirs:
                    findmnt_cmd = f"findmnt {dir} > /dev/null 2>&1"
                    umount_cmd = f"umount {dir} > /dev/null 2>&1"
                    if os.system(findmnt_cmd) == 0:
                        os.system(umount_cmd)
                        if os.system(findmnt_cmd) == 0:
                            UMNT_OK = False
            umount_counter += 1 if UMNT_OK else 0
        time.sleep(0.01)

# Function to recursively delete temp files
def recursive_delete(path):
    # perform some sanity checks
    if not path.startswith(ZYPPERONI_TMP_DIR):
        return False
    command = f"rm -r {quote(path)} > /dev/null 2>&1"
    os.system(command)
    return True

# Function to cleanup on zypperoni exit
def zypperoni_cleanup():
    release_zypp_lock()
    recursive_delete(ZYPPERONI_TMP_DIR)

# Function to get output and exit code of shell command
def shell_exec(command):
    res = subprocess.run(command, shell=True, capture_output=True, encoding="utf8", errors="replace")
    output = res.stdout + res.stderr
    return output.strip(), res.returncode

# Async function to perform zypper shell commands
async def zypper_task(lock, UUID, task_type, task_item, total_items, item_counter):
    try:
        async with lock:
            uuid = UUID.pop()
        log_messages = {}
        commands = ""
        temp_dir = f"{ZYPPERONI_TMP_DIR}/{uuid}/rootfs"
        if task_type == "ref":
            log_messages.update({"start": f"{COLOR_INFO}Refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"success": f"{COLOR_INFO}Successfully refreshed repo {task_item!r}{COLOR_RESET}"})
            log_messages.update({"error": f"{COLOR_ERROR}Error refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            if not os.path.isdir(temp_dir):
                commands = refresh_mount_commands + refresh_shell_commands
                commands = commands.format(
                    uuid=uuid,
                    refresh_type="refresh",
                    repo_alias=task_item,
                )
            else:
                commands = refresh_shell_commands.format(
                    uuid=uuid,
                    refresh_type="refresh",
                    repo_alias=task_item,
                )
        elif task_type == "force-ref":
            log_messages.update({"start": f"{COLOR_INFO}Force refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"success": f"{COLOR_INFO}Successfully force refreshed repo {task_item!r}{COLOR_RESET}"})
            log_messages.update({"error": f"{COLOR_ERROR}Error force refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while force refreshing repo [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            if not os.path.isdir(temp_dir):
                commands = refresh_mount_commands + refresh_shell_commands
                commands = commands.format(
                    uuid=uuid,
                    refresh_type="refresh --force",
                    repo_alias=task_item,
                )
            else:
                commands = refresh_shell_commands.format(
                    uuid=uuid,
                    refresh_type="refresh --force",
                    repo_alias=task_item,
                )
        elif task_type in ["dup", "dup-download", "in", "in-download", "inr", "inr-download"]:
            log_messages.update({"start": f"{COLOR_INFO}Downloading package [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"success": f"{COLOR_INFO}Successfully downloaded package {task_item!r}{COLOR_RESET}"})
            log_messages.update({"error": f"{COLOR_ERROR}Error downloading package [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while downloading package [{item_counter}/{total_items}] {task_item!r}{COLOR_RESET}"})
            if not os.path.isdir(temp_dir):
                commands = download_mount_commands + download_shell_commands
                commands = commands.format(
                    uuid=uuid,
                    pkg_name=task_item,
                )
            else:
                commands = download_shell_commands.format(
                    uuid=uuid,
                    pkg_name=task_item,
                )
        logging.info(log_messages.get("start"))
        proc = await asyncio.create_subprocess_shell(
            commands,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()
        if proc.returncode == 0:
            logging.info(log_messages.get("success"))
        else:
            logging.error(f"{log_messages.get('error')}. zypper exit code: {proc.returncode}")
        if stdout:
            logging.debug(f'[zypper output]\n{stdout.decode()}')
        if stderr:
            logging.debug(f'[zypper error]\n{stderr.decode()}')
        async with lock:
            UUID.append(uuid)
    except asyncio.exceptions.CancelledError:
        logging.debug(log_messages.get("exception"))

# Async function to perform multiple tasks concurrently
async def main_task(num_jobs, task_type, task_items, no_confirm=None):
    EXCEPTION_OCCUR = False
    # init array of temp dir UUIDs corresponding to max num of jobs
    UUID = [f"{uuid4()!s}" for _ in range(num_jobs)]
    UUID_UNCHANGED = UUID.copy()
    total_items = len(task_items)
    item_counter = 0
    if task_type == "in":
        install_pkgs = task_items.copy()
    try:
        # start processing tasks
        lock = asyncio.Lock()
        while task_items:
            if len(UUID) == 0:
                await asyncio.sleep(0.1)
                continue
            log_messages = {}
            task_item = task_items.pop(0)
            item_counter += 1
            if task_type == "ref":
                log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while processing tasks to refresh repo{COLOR_RESET}"})
            elif task_type == "force-ref":
                log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while processing tasks to force refresh repo{COLOR_RESET}"})
            elif task_type in ["dup", "dup-download", "in", "in-download", "inr", "inr-download"]:
                log_messages.update({"exception": f"{COLOR_ERROR}Received SIGINT while processing tasks to download packages{COLOR_RESET}"})
            asyncio.create_task(zypper_task(lock, UUID, task_type, task_item, total_items, item_counter))
            await asyncio.sleep(0.1)
        # finished processing all tasks
        tasks = asyncio.all_tasks()
        # wait for all tasks to finish
        while len(tasks) > 1:
            tasks = asyncio.all_tasks()
            await asyncio.sleep(0.1)
    except asyncio.exceptions.CancelledError:
        EXCEPTION_OCCUR = True
        logging.debug(log_messages.get("exception"))
        logging.info("Cancelling pending tasks...")
        for task in asyncio.all_tasks():
            task.cancel()
            await asyncio.sleep(0.1)
    finally:
        # cleanup temp mounts
        logging.info("Cleaning up temp mounts...")
        unmount(UUID_UNCHANGED.copy())
        # cleanup temp dir
        logging.info("Cleaning up temp directory...")
        recursive_delete(ZYPPERONI_TMP_DIR)
        # release zypper exclusive lock
        release_zypp_lock()
        # perform additional zypper commands (if any) on no exception
        if not EXCEPTION_OCCUR:
            msg = f"{COLOR_INFO}Zypperoni has finished its tasks. Handing you over to zypper...{COLOR_RESET}"
            if task_type == "dup":
                logging.info(msg)
                command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if no_confirm else ''} --no-cd dist-upgrade"
                os.system(command)
            elif task_type == "in":
                logging.info(msg)
                command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if no_confirm else ''} --no-cd install {' '.join(install_pkgs)}"
                os.system(command)
            elif task_type == "inr":
                logging.info(msg)
                command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if no_confirm else ''} --no-cd install-new-recommends"
                os.system(command)

################################

# Parse command, options, and args
COMMAND = ""
OPT = []
ARG = []
for index, item in enumerate(sys.argv):
    if index == 0:
        continue
    if item in VALID_OPT:
        OPT.append(item)
    if item in VALID_CMD:
        COMMAND = item
        ARG = sys.argv[index+1:]
        break

# Print help
if "--help" in OPT:
    print(help_text.strip())
    zypperoni_cleanup()
    sys.exit()

# Print version
if "--version" in OPT:
    print(f"zypperoni v{ZYPPERONI_VERSION}")
    zypperoni_cleanup()
    sys.exit()

# Validate command
if not COMMAND:
    print("No valid command provided. See usage below.\n")
    print(help_text.strip())
    zypperoni_cleanup()
    sys.exit(1)
if COMMAND in ["in", "in-download"] and not ARG:
    print(f"No arguments (packages) provided for command {COMMAND!r}. See usage below.\n")
    print(help_text.strip())
    zypperoni_cleanup()
    sys.exit(1)

# Validate options
for opt in OPT:
    if opt not in VALID_OPT:
        print(f"Invalid option {opt!r}. See usage below.\n")
        print(help_text.strip())
        zypperoni_cleanup()
        sys.exit(1)

DEBUG = True if "--debug" in OPT else False
NO_CONFIRM = True if "--no-confirm" in OPT else False
MAX_JOBS = 10
if "--max-jobs" in OPT:
    try:
        num_jobs = int(sys.argv[sys.argv.index("--max-jobs") + 1])
        if num_jobs in range(1, 21):
            MAX_JOBS = num_jobs
        else:
            raise ValueError
    except ValueError:
        print("Invalid value for option '--max-jobs'. Must be between 1 to 20 (inclusive)")
        zypperoni_cleanup()
        sys.exit(2)
    except IndexError:
        print("No value provided for option '--max-jobs'")
        zypperoni_cleanup()
        sys.exit(2)


# Setup logging
logging.basicConfig(
    stream=sys.stdout,
    format="%(asctime)s: %(levelname)s: %(message)s",
    level=logging.DEBUG if DEBUG else logging.INFO,
)

# Bail out if we're not root
if os.getuid() != 0:
    logging.error("Bailing out, program must be run with root privileges")
    zypperoni_cleanup()
    sys.exit(3)

# Bail out if required dependencies are not available
programs = ["zypper", "echo", "ps", "sed", "awk", "mkdir", "cat", "dirname", "basename", \
            "readlink", "mount", "chroot", "umount", "sleep", "rm", "env", "findmnt"]
for program in programs:
    out, ret = shell_exec(f"command -v {program}")
    if not out:
        logging.error(f"Bailing out, missing required dependency {program!r} in PATH ({os.environ.get('PATH')}) " \
            f"for user {os.environ.get('USER')!r}. The following shell tools " \
            f"are required for zypperoni to function: {', '.join(programs)}"
        )
        zypperoni_cleanup()
        sys.exit(4)

# Check if zypper is already running
pid = None
pid_program = None
if os.path.isfile(ZYPPER_PID_FILE):
    with open(ZYPPER_PID_FILE, "r") as f:
        pid = f.read().strip()
        try:
            pid = int(pid)
        except ValueError:
            pid = None
        if pid:
            pid_program, ret = shell_exec(f"ps -p {pid} | sed '1d' | awk '{{print $4}}'")
            if pid_program:
                msg = f"zypper is already invoked by the application with pid {pid} ({pid_program}).\n" \
                "Close this application before trying again."
                logging.error(msg)
                zypperoni_cleanup()
                sys.exit(5)

# Handle commands: ref, force-ref
if COMMAND in ["ref", "force-ref"]:
    # get all enabled repos
    logging.info("Getting all enabled repos")
    REPO_ALIAS = []
    xml_output, ret = shell_exec("env -i zypper --non-interactive --no-cd --xmlout repos")
    logging.debug(xml_output)
    get_zypp_lock()
    docroot = ET.fromstring(xml_output)
    for item in docroot.iter("repo"):
        if item.attrib["enabled"] == "1":
            REPO_ALIAS.append(item.attrib["alias"])
    logging.debug(f"Enabled repos: {REPO_ALIAS}")
    if not REPO_ALIAS:
        logging.info("No repos found. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    try:
        asyncio.run(main_task(MAX_JOBS, COMMAND, REPO_ALIAS))
    except asyncio.exceptions.CancelledError:
        logging.debug("Received SIGINT for asyncio runner")
    except:
        logging.exception("Unknown exception for asyncio runner")

# Handle commands: dup, dup-download
elif COMMAND in ["dup", "dup-download"]:
    # get info about dup packages
    logging.info("Getting all packages to be downloaded for distribution upgrade")
    xml_output, ret = shell_exec("env -i zypper --non-interactive --no-cd --xmlout dist-upgrade --dry-run")
    logging.debug(xml_output)
    if ret == 0 and xml_output.find("Nothing to do") != -1:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    get_zypp_lock()
    docroot = ET.fromstring(xml_output)
    num_pkgs = None
    for item in docroot.iter('install-summary'):
        download_size_bytes = float(item.attrib["download-size"])
        diff_bytes = float(item.attrib["space-usage-diff"])
        num_pkgs = int(item.attrib["packages-to-change"])
        logging.info(f"Number of packages to download: {num_pkgs}")
        logging.info(f"Total download size: {download_size_bytes/1000**2:.2f} MB")
        if COMMAND == "dup":
            logging.info(f"Space usage difference after operation: {diff_bytes/1000**2:+.2f} MB")
    if not num_pkgs:
        logging.warning("There are package conflicts that must be manually resolved. See output of:\n" \
                        "zypper --non-interactive --no-cd dist-upgrade --dry-run")
        zypperoni_cleanup()
        sys.exit()
    # parse all packages from xml output
    DUP_PKG = []
    for item in docroot.iter("solvable"):
        if item.attrib["type"] == "package":
            DUP_PKG.append(item.attrib["name"])
    # parse all packages to be removed
    RM_PKG = []
    for rm in docroot.iter("to-remove"):
        for solv in rm.findall("solvable"):
            if solv.get("type") == "package":
                RM_PKG.append(solv.get("name"))
    DUP_PKG = list( set(DUP_PKG) - set(RM_PKG) )
    DUP_PKG.sort()
    if not DUP_PKG:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # do not download if all packages are already in cache
    if COMMAND == "dup-download" and download_size_bytes == 0:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # proceed straight to dup if all packages are in cache
    if COMMAND == "dup" and download_size_bytes == 0:
        zypperoni_cleanup()
        logging.info("Zypperoni has finished its tasks. Handing you over to zypper...")
        command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if NO_CONFIRM else ''} --no-cd dist-upgrade"
        os.system(command)
        sys.exit()
    logging.info(f"Packages to download: {' '.join(DUP_PKG)}")
    if not NO_CONFIRM and not query_yes_no("Would you like to continue?", default="yes"):
        zypperoni_cleanup()
        sys.exit()
    try:
        asyncio.run(main_task(MAX_JOBS, COMMAND, DUP_PKG, NO_CONFIRM))
    except asyncio.exceptions.CancelledError:
        logging.debug("Received SIGINT for asyncio runner")
    except:
        logging.exception("Unknown exception for asyncio runner")

# Handle commands: in, in-download
elif COMMAND in ["in", "in-download"]:
    # get info about install packages
    logging.info("Getting packages and their dependencies to be downloaded for installation")
    xml_output, ret = shell_exec(f"env -i zypper --non-interactive --no-cd --xmlout install --dry-run {' '.join(ARG)}")
    logging.debug(xml_output)
    if ret == 0 and xml_output.find("Nothing to do") != -1:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    get_zypp_lock()
    docroot = ET.fromstring(xml_output)
    NO_ERR = False
    num_pkgs = None
    for item in docroot.iter('install-summary'):
        download_size_bytes = float(item.attrib["download-size"])
        diff_bytes = float(item.attrib["space-usage-diff"])
        num_pkgs = int(item.attrib["packages-to-change"])
        logging.info(f"Number of packages to download: {num_pkgs}")
        logging.info(f"Total download size: {download_size_bytes/1000**2:.2f} MB")
        logging.info(f"Space usage difference after operation: {diff_bytes/1000**2:+.2f} MB")
        NO_ERR = True
    if not num_pkgs:
        logging.warning("There are package conflicts that must be manually resolved. See output of:\n" \
                        "zypper --non-interactive --no-cd dist-upgrade --dry-run")
        zypperoni_cleanup()
        sys.exit()
    if not NO_ERR:
        friendly_output = ""
        for item in docroot.iter("message"):
            friendly_output += item.text + "\n"
        logging.error(f"There was an error processing your request.\n[zypper output]\n{friendly_output.strip()}")
        zypperoni_cleanup()
        sys.exit(6)
    # parse all packages from xml output
    IN_PKG = []
    for item in docroot.iter("solvable"):
        if item.attrib["type"] == "package":
            IN_PKG.append(item.attrib["name"])
    # parse all packages to be removed
    RM_PKG = []
    for rm in docroot.iter("to-remove"):
        for solv in rm.findall("solvable"):
            if solv.get("type") == "package":
                RM_PKG.append(solv.get("name"))
    IN_PKG = list( set(IN_PKG) - set(RM_PKG) )
    IN_PKG.sort()
    if not IN_PKG:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # do not download if all packages are already in cache
    if COMMAND == "in-download" and download_size_bytes == 0:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # proceed straight to install if all packages are in cache
    if COMMAND == "in" and download_size_bytes == 0:
        zypperoni_cleanup()
        logging.info("Zypperoni has finished its tasks. Handing you over to zypper...")
        command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if NO_CONFIRM else ''} --no-cd install {' '.join(ARG)}"
        os.system(command)
        sys.exit()
    logging.info(f"Packages to download: {' '.join(IN_PKG)}")
    if not NO_CONFIRM and not query_yes_no("Would you like to continue?", default="yes"):
        zypperoni_cleanup()
        sys.exit()
    try:
        asyncio.run(main_task(MAX_JOBS, COMMAND, IN_PKG, NO_CONFIRM))
    except asyncio.exceptions.CancelledError:
        logging.debug("Received SIGINT for asyncio runner")
    except:
        logging.exception("Unknown exception for asyncio runner")

# Handle commands: inr, inr-download
elif COMMAND in ["inr", "inr-download"]:
    # get info about recommended install packages
    logging.info("Getting new packages and their dependencies to be downloaded for recommended installation")
    xml_output, ret = shell_exec(f"env -i zypper --non-interactive --no-cd --xmlout install-new-recommends --dry-run")
    logging.debug(xml_output)
    if ret == 0 and xml_output.find("Nothing to do") != -1:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    get_zypp_lock()
    docroot = ET.fromstring(xml_output)
    num_pkgs = None
    for item in docroot.iter('install-summary'):
        download_size_bytes = float(item.attrib["download-size"])
        diff_bytes = float(item.attrib["space-usage-diff"])
        num_pkgs = int(item.attrib["packages-to-change"])
        logging.info(f"Number of packages to download: {num_pkgs}")
        logging.info(f"Total download size: {download_size_bytes/1000**2:.2f} MB")
        logging.info(f"Space usage difference after operation: {diff_bytes/1000**2:+.2f} MB")
    if not num_pkgs:
        logging.warning("There are package conflicts that must be manually resolved. See output of:\n" \
                        "zypper --non-interactive --no-cd dist-upgrade --dry-run")
        zypperoni_cleanup()
        sys.exit()
    # parse all packages from xml output
    INR_PKG = []
    for item in docroot.iter("solvable"):
        if item.attrib["type"] == "package":
            INR_PKG.append(item.attrib["name"])
    # parse all packages to be removed
    RM_PKG = []
    for rm in docroot.iter("to-remove"):
        for solv in rm.findall("solvable"):
            if solv.get("type") == "package":
                RM_PKG.append(solv.get("name"))
    INR_PKG = list( set(INR_PKG) - set(RM_PKG) )
    INR_PKG.sort()
    if not INR_PKG:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # do not download if all packages are already in cache
    if COMMAND == "inr-download" and download_size_bytes == 0:
        logging.info("Nothing to do. Exiting...")
        zypperoni_cleanup()
        sys.exit()
    # proceed straight to inr if all packages are in cache
    if COMMAND == "inr" and download_size_bytes == 0:
        zypperoni_cleanup()
        logging.info("Zypperoni has finished its tasks. Handing you over to zypper...")
        command = f"env ZYPP_SINGLE_RPMTRANS=1 zypper {'--non-interactive' if NO_CONFIRM else ''} --no-cd install-new-recommends"
        os.system(command)
        sys.exit()
    logging.info(f"Packages to download: {' '.join(INR_PKG)}")
    if not NO_CONFIRM and not query_yes_no("Would you like to continue?", default="yes"):
        zypperoni_cleanup()
        sys.exit()
    try:
        asyncio.run(main_task(MAX_JOBS, COMMAND, INR_PKG, NO_CONFIRM))
    except asyncio.exceptions.CancelledError:
        logging.debug("Received SIGINT for asyncio runner")
    except:
        logging.exception("Unknown exception for asyncio runner")
